// axiome (document = suite de déclarations et de définitions de fonctions)
DOCUMENT        -> ANY_DECL
                 | FUNC_DEF
                 | DOCUMENT ANY_DECL
                 | DOCUMENT FUNC_DEF

VAR             -> identifier

CONST           -> num
                 | 'char'

FONCTION_APPEL  -> identifier '(' EXPR ')' // défini plus bas
                 | identifier '(' ')'

// celui qui peut être affecté
LVALUE          -> VAR
                 | VAR[EXPR]

EXPR_UNIQ       -> LVALUE
                 | LVALUE[EXPR]
                 | FONCTION_APPEL[EXPR]
                 | LVALUE++
                 | LVALUE--
                 | --LVALUE
                 | ++LVALUE
                 | +EXPR_UNIQ
                 | -EXPR_UNIQ
                 | EXPR_UNIQ / EXPR_UNIQ
                 | EXPR_UNIQ * EXPR_UNIQ
                 | EXPR_UNIQ % EXPR_UNIQ
                 | EXPR_UNIQ + EXPR_UNIQ
                 | EXPR_UNIQ - EXPR_UNIQ
                 | EXPR_UNIQ < EXPR_UNIQ
                 | EXPR_UNIQ <= EXPR_UNIQ
                 | EXPR_UNIQ > EXPR_UNIQ
                 | EXPR_UNIQ => EXPR_UNIQ
                 | EXPR_UNIQ == EXPR_UNIQ
                 | EXPR_UNIQ != EXPR_UNIQ
                 | EXPR_UNIQ && EXPR_UNIQ
                 | EXPR_UNIQ || EXPR_UNIQ
                 | LVALUE = EXPR_UNIQ
                 | LVALUE += EXPR_UNIQ
                 | LVALUE -= EXPR_UNIQ
                 | LVALUE *= EXPR_UNIQ
                 | LVALUE /= EXPR_UNIQ
                 | LVALUE %= EXPR_UNIQ
                 | FONCTION_APPEL

EXPR            -> EXPR_UNIQ
                 | EXPR_UNIQ, EXPR

TYPE_VAR        -> type_char
                 | int_32
                 | int_64

DECL_VAR        -> identifier
                 | identifier[num]
                 | identifier[]

// type a, b = val, c = val, d, e
DECL            -> TYPE_VAR DECL_1

DECL_1          -> DECL_2
                 | DECL_1, DECL_2

DECL_2          -> DECL_VAR
                 | DECL_VAR = EXPR_UNIQ

// "type a" seulement
DECL_UNIQ       -> TYPE_VAR DECL_VAR

TYPE_FUNC       -> TYPE_VAR
                 | void

LIST_ARGS_FUNC  -> TYPE_VAR
                 | DECL_UNIQ
                 | TYPE_LIST ',' TYPE_VAR 
                 | TYPE_LIST ',' DECL_UNIQ

DECL_ARGS       -> '('')'
                 | '(' LIST_ARGS_FUNC ')'

FUNC_DECL       -> TYPE_FUNC identifier DECL_ARGS ;

ANY_DECL        -> DECL
                 | FUNC_DECL

DECL_UNIQ_LIST  -> DECL_UNIQ
                 | DECL_UNIQ_LIST ',' DECL_UNIQ

ARGS            -> '('')'
                 | '(' DECL_UNIQ_LIST ')'

FUNC_DEF        -> TYPE_FUNC identifier ARGS BLOCK

BLOCK_ITEM      -> DECL
                 | STAT // defini plus bas par (IF | ITER| BLOCK | EXPR ';' | ';' )

BLOCK_ITEM_LIST -> BLOCK_ITEM
                 | BLOCK_ITEM_LIST BLOCK_ITEM

BLOCK           -> ‘{‘ '}'
                 | ‘{‘ BLOCK_ITEM_LIST ‘}’

IF              -> if '(' EXPR ')' STAT
                 | if '(' EXPR ')' STAT else STAT

EXPR_FOR        -> EXPR | /* vide */

ITER            -> while '(' EXPR ')' STAT
                 | for '(' EXPR_FOR ';' EXPR_FOR ';' EXPR_FOR ')' STAT

RETURN_STAT     -> return ';'
                 | return EXPR ';'

STAT            -> IF
                 | ITER
                 | BLOCK
                 | EXPR ';'
                 | ';'
                 | RETURN_STAT


// terminaux
n                : [0-9]
c                : . // n'importe quoi
num              : -?{n}+
char             : c
identifier       : {c}[{c}|{n}]*

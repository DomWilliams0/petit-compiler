// axiome (document = suite de déclarations et de définitions de fonctions)
DOCUMENT        -> ANY_DECL_LIST
                 | FUNC_DEF
                 | DOCUMENT ANY_DECL_LIST
                 | DOCUMENT FUNC_DEF

VAR             -> identifier

CONST           -> num
                 | 'char'

FONCTION_APPEL  -> identifier '(' EXPR ')' // défini plus bas
                 | identifier '(' ')'

PRIMARY_EXPR    -> CONST
                 | VAR

POSTFIX_EXPR    -> PRIMARY_EXPR
                 | PRIMARY_EXPR++
                 | PRIMARY_EXPR--
                 | PRIMARY_EXPR[PRIMARY_EXPR]

UNARY_EXPR      -> POSTFIX_EXPR
                 | --POSTFIX_EXPR
                 | ++POSTFIX_EXPR
                 | FONCTION_APPEL 

MULT_EXPR       -> UNARY_EXPR
                 | MULT_EXPR * UNARY_EXPR
                 | MULT_EXPR / UNARY_EXPR
                 | MULT_EXPR % UNARY_EXPR

ADD_EXPR        -> MULT_EXPR
                 | ADD_EXPR + MULT_EXR
                 | ADD_EXPR - MULT_EXR

REL_EXPR        -> ADD_EXPR
                 | REL_EXPR < ADD_EXPR
                 | REL_EXPR > ADD_EXPR
                 | REL_EXPR <= ADD_EXPR
                 | REL_EXPR >= ADD_EXPR

EQU_EXPR        -> REL_EXPR
                 | EQU_EXPR == REL_EXPR
                 | EQU_EXPR != REL_EXPR

AND_EXPR        -> EQU_EXPR
                 | AND_EXPR && EQU_EXPR

OR_EXPR         -> AND_EXPR
                 | OR_EXPR |
                 | AND_EXPR

AFF_OP          -> =
                 | *=
                 | /=
                 | %=
                 | +=
                 | -=

AFF_EXPR        -> OR_EXPR
                 | UNARY_EXPR AFF_OP AFF_EXPR


EXPR            -> AFF_EXPR
                 | EXPR ‘,’ AFF_EXPR


TYPE_VAR        -> type_char
                 | int_32
                 | int_64

DECL_VAR        -> identifier
                 | identifier[num]
                 | identifier[]

// type a, b = val, c = val, d, e
DECL            -> TYPE_VAR DECL_1

DECL_1          -> DECL_2
                 | DECL_1, DECL_2

DECL_2          -> AFF_EXPR
                 | DECL_VAR

// "type a" seulement
DECL_UNIQ       -> TYPE_VAR DECL_VAR

TYPE_FUNC       -> TYPE_VAR
                 | void

LIST_ARGS_FUNC  -> TYPE_VAR
                 | DECL_UNIQ
                 | TYPE_LIST ',' TYPE_VAR 
                 | TYPE_LIST ',' DECL_UNIQ

DECL_ARGS       -> '('')'
                 | '(' LIST_ARGS_FUNC ')'

FUNC_DECL       -> TYPE_FUNC identifier DECL_ARGS ;

ANY_DECL        -> DECL
                 | FUNC_DECL

ANY_DECL_LIST   -> ANY_DECL
                 | ANY_DECL_LIST ANY_DECL

DECL_UNIQ_LIST  -> DECL_UNIQ
                 | DECL_UNIQ_LIST ',' DECL_UNIQ

ARGS            -> '('')'
                 | '(' DECL_UNIQ_LIST ')'

FUNC_DEF        -> TYPE_FUNC identifier ARGS BLOCK

BLOCK_ITEM      -> DECL
                 | STAT // defini plus bas par (IF | ITER| BLOCK | EXPR ';' | ';' )

BLOCK_ITEM_LIST -> BLOCK_ITEM
                 | BLOCK_ITEM_LIST BLOCK_ITEM

BLOCK           -> ‘{‘ '}'
                 | ‘{‘ BLOCK_ITEM_LIST ‘}’

IF              -> if '(' EXPR ')' STAT
                 | if '(' EXPR ')' STAT else STAT

EXPR_FOR        -> EXPR | /* vide */

ITER            -> while '(' EXPR ')' STAT
                 | for '(' EXPR_FOR ';' EXPR_FOR ';' EXPR_FOR ')' STAT

RETURN_STAT     -> return ';'
                 | return EXPR ';'
                 
STAT            -> IF
                 | ITER
                 | BLOCK
                 | EXPR ';'
                 | ';'
                 | RETURN_STAT


// regex
identifier : {C}[{C}|{N}]*

num        : -?{N}+

char       : X
